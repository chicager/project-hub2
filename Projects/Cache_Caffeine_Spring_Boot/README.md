# Пример работы с кешем в Spring Boot

------------

## Общее инфо
В Spring Boot есть несколько встроенных провайдеров кеша, которые доступны "из коробки". Вот основные варианты:
1.	Simple Cache (Простой кеш)
      - Это самый базовый провайдер, который использует ConcurrentHashMap
      - Доступен по умолчанию, если не указан другой провайдер кеша
      - Не рекомендуется для продакшена, так как не имеет механизмов очистки и ограничения размера
2.	Caffeine
      - Более продвинутый провайдер, который мы используем в нашем проекте
      - Предоставляет множество полезных функций:
        - Настройка времени жизни кеша
        - Ограничение размера
        - Различные стратегии вытеснения
        - Статистика использования
        - Асинхронная загрузка
3.	EhCache
      - Классический провайдер кеша
      - Требует дополнительной конфигурации XML
      - Хорошо подходит для распределенного кеширования
4.	Redis
      - Распределенный кеш
      - Отлично подходит для микросервисной архитектуры
      - Требует отдельного сервера Redis

В нашем проекте мы используем Caffeine, потому что:
1.	Он более современный и производительный
2.	Имеет богатый функционал
3.	Не требует дополнительной инфраструктуры
4.	Хорошо подходит для большинства случаев использования

Если вы хотите использовать встроенный Simple Cache, то можно просто убрать зависимость Caffeine из pom.xml и изменить конфигурацию. Вот как это будет выглядеть:
```
@Configuration
public class CacheConfig {

  @Bean
  public CacheManager cacheManager() {
    return new ConcurrentMapCacheManager("products", "productList");
  }
}
```
Однако, я рекомендую использовать Caffeine или Redis, потому что:
1.	Simple Cache не имеет механизмов очистки
2.	Нет контроля над размером кеша
3.	Нет механизмов вытеснения данных
4.	Нет статистики использования
5.	Не подходит для продакшена

Если ваше приложение небольшое и используется только для разработки/тестирования, то Simple Cache может быть достаточным. Но для продакшена лучше использовать Caffeine или Redis, так как они предоставляют больше возможностей и лучшую производительность.

Caffeine является одним из самых популярных и рекомендуемых выборов для локального кеширования в Spring Boot приложениях. Вот почему:
1.	Производительность
      - Caffeine оптимизирован для высокой производительности
      - Использует современные алгоритмы кеширования
      - Имеет низкую задержку при операциях чтения/записи
2.	Богатый функционал
      - Настройка времени жизни кеша (TTL)
      - Различные стратегии вытеснения (LRU, LFU)
      - Автоматическая очистка устаревших данных
      - Статистика использования кеша
      - Асинхронная загрузка данных
3.	Простота использования
      - Не требует дополнительной инфраструктуры
      - Простая конфигурация через Java-код
      - Хорошая интеграция со Spring Boot
4.	Активное развитие
      - Регулярные обновления
      - Хорошая документация
      - Большое сообщество

Альтернативы для локального кеширования:
1.	EhCache - классический вариант, но менее производительный
2.	Guava Cache - хороший вариант, но Caffeine является его улучшенной версией
3.	Simple Cache - только для разработки/тестирования

Для распределенного кеширования обычно используют:
1.	Redis - самый популярный выбор
2.	Hazelcast - для распределенных вычислений
3.	Apache Ignite - для сложных сценариев

Но для локального кеширования Caffeine является оптимальным выбором в большинстве случаев, так как сочетает в себе производительность, функциональность и простоту использования.

------------

## Описание проекта
- Для кеша используется Caffeine
- В приложении продемонстрировано настройка разного логгирования для разных пакетов
- Помимо стандартного управления кешем через Spring приведен пример программного управления кешем
- Написаны тесты и реализован профиль для них (application-test.yml)

## Возможности

- Кеширование результатов запросов
- Условное кеширование
- Программное управление кешем
- Мониторинг состояния кеша

## Конфигурация кеша

- Используется Caffeine как провайдер кеша
- Настроено время жизни кеша (60 минут)
- Установлены начальная емкость (100) и максимальный размер (500)

## Примеры кеширования

В проекте представлены различные примеры использования кеширования:

1. Простое кеширование:
```java
@Cacheable(value = "products", key = "#id")
public Optional<Product> getProductById(Long id)
```

2. Условное кеширование:
```java
@Cacheable(value = "productList", condition = "#minPrice > 0")
public List<Product> getProductsByMinPrice(Double minPrice)
```

3. Обновление кеша:
```java
@CachePut(value = "products", key = "#product.id")
public Product updateProduct(Product product)
```

4. Удаление из кеша:
```java
@CacheEvict(value = "products", key = "#id")
public void deleteProduct(Long id)
```

## API Endpoints

### Продукты

- `GET /api/products/{id}` - Получить продукт по ID
- `GET /api/products/price/{minPrice}` - Получить продукты с минимальной ценой
- `POST /api/products` - Создать новый продукт
- `PUT /api/products/{id}` - Обновить продукт
- `DELETE /api/products/{id}` - Удалить продукт
- `GET /api/products/search?name={name}&price={price}` - Поиск по имени и цене

### Управление кешем

- `GET /api/products/cache/names` - Получить список всех кешей
- `GET /api/products/cache/{cacheName}/contents` - Получить содержимое кеша
- `GET /api/products/cache/{cacheName}/stats` - Получить статистику кеша
- `POST /api/products/cache/clear-all` - Очистить все кеши
- `POST /api/products/cache/{cacheName}/clear` - Очистить конкретный кеш
- `DELETE /api/products/cache/{cacheName}/{key}` - Удалить значение из кеша

## Примеры запросов

### Создание продукта
```http
POST http://localhost:8080/api/products
Content-Type: application/json

{
    "name": "Test Product",
    "description": "Test Description",
    "price": 100.0,
    "stock": 10
}
```

### Получение статистики кеша
```http
GET http://localhost:8080/api/products/cache/products/stats
```

Пример ответа:
```json
{
    "hitCount": 10,
    "missCount": 3,
    "evictionCount": 0,
    "estimatedSize": 2
}
```

## База данных

Проект использует встроенную базу данных H2:
- URL: `jdbc:h2:mem:testdb`
- Консоль H2: `http://localhost:8080/h2-console`
- Пользователь: `sa`
- Пароль: пустой


## Тестирование

В проекте есть готовый файл `http/product.http` с примерами всех запросов

## Основные аннотации для кеширования:

- @Cacheable - кеширует результат метода. При повторном вызове с теми же параметрами результат берется из кеша.
- @CachePut - обновляет кеш при изменении данных.
- @CacheEvict - очищает кеш при удалении данных.

## Лучшие практики

- Кешировать только те данные, которые часто запрашиваются и редко меняются
- Использовать условия кеширования для предотвращения кеширования нежелательных данных
- Правильно очищать кеш при изменении данных
- Использовать транзакции при работе с кешем и базой данных
- Настраивать размер и время жизни кеша в зависимости от требований приложения

## Когда использовать кеш:

- При частых запросах одних и тех же данных
- При сложных вычислениях или запросах к базе данных
- При работе с внешними API
- При высокой нагрузке на базу данных
- При необходимости улучшения производительности

## Когда не использовать кеш:

- При частых изменениях данных
- При работе с конфиденциальными данными
- При необходимости всегда актуальных данных
- При небольшом количестве данных

