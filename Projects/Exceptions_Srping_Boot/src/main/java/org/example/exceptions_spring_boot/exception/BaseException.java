package org.example.exceptions_spring_boot.exception;

import lombok.Getter;

/*
В данном случае мы используем только @Getter потому что это класс исключения,
и он должен быть иммутабельным (неизменяемым). Вот причины:
  Иммутабельность исключений:
    После создания исключения его состояние не должно меняться
    Это особенно важно при многопоточности
    Сеттеры здесь не нужны, так как все поля устанавливаются в конструкторе
    Значения устанавливаются один раз в конструкторе
    Сеттеры для final полей невозможны
*/

/*
@RequiredArgsConstructor не подходит здесь по нескольким причинам:
  Наследование от RuntimeException:
    RuntimeException имеет свои конструкторы, которые нужно вызвать
  Varargs параметр (Object... args):
    @RequiredArgsConstructor не поддерживает varargs параметры.

Проблемы:
  Потеряем возможность передавать произвольное количество аргументов
  Не сможем вызвать конструктор родителя (RuntimeException)
  Придется передавать массив явно: new MyException("key", new Object[]{"arg1", "arg2"})
*/
@Getter
public abstract class BaseException extends RuntimeException {

    private final String messageKey;
    private final Object[] args;

    /*
    protected конструктор используется здесь потому что BaseException - это абстрактный класс,
    который предназначен только для наследования.
    Давайте разберем подробнее:
      Нельзя создать экземпляр абстрактного класса напрямую
      Он служит только базой для других исключений

    Уровни доступа:
      // Плохо - private не позволит наследникам использовать конструктор
      private BaseException(String messageKey, Object... args) { }

      // Плохо - public позволит создавать экземпляр базового класса (если бы он не был абстрактным)
      public BaseException(String messageKey, Object... args) { }

      // Хорошо - protected разрешает доступ только наследникам
      protected BaseException(String messageKey, Object... args) { }

      Абстрактный класс нельзя инстанцировать напрямую даже с public конструктором, однако использование protected
      здесь все равно является хорошей практикой по нескольким причинам:
        Явное указание намерений
        Следует принципу наименьших привилегий
        Защита от будущих изменений (страховка от возможных ошибок в будущем)
    */
    protected BaseException(String messageKey, Object... args) {
        /*
        Зачем вызывать родительский конструктор super(messageKey):

        Логирование:
          Без super() - многие логгеры не смогут получить сообщение об ошибке
          С super() - сообщение будет доступно везде, где используется getMessage()
        Отладка:
          Без super() - стектрейс менее информативен
          С super() - в стектрейсе видно сообщение об ошибке
        Интеграция:
          Без super() - некоторые фреймворки могут некорректно обработать исключение
          С super() - стандартная обработка работает как ожидается
        Поэтому рекомендуется всегда передавать сообщение в конструктор родительского класса.
        */
        super(messageKey);
        this.messageKey = messageKey;
        this.args = args != null ? args.clone() : new Object[0];
    }
}
